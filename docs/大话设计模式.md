## 设计模式

### 类图

![](img/class.PNG)

---

### 面向对象设计六大原则

#### 单一职责原则

![](img/单一职责原则.JPG)



#### 开放封闭原则

![](img/开闭原则.JPG)

#### 依赖倒置原则

![](img/依赖倒置原则.JPG)

#### 迪米特法则



---



### 简单工厂模式

该模式主要负责解决对象的创建问题，工厂类负责根据不同的需求生产对象。

![factory](img/factory.PNG)

**优点：**

1. 客户端免于负责创建产品的责任。
2. 可以不修改客户端代码增加产品，提高系统灵活性。

**缺点：**

1. 工厂类集中了所有创建对象的逻辑，容易对系统造成影响。
2. 一旦商品发生增减，就要修改工厂类破坏封装性。

**使用场景：**

1. 所需创建对象数量较少，改动少
2. 客户端无需关心对象的创建



### 策略模式

在简单工厂模式的基础上，将创建产品的责任又放回客户端，采用多态，`Context`中使用父类参数，传入子类对象做出自己的行为。

![strategy](img/strategy.PNG)

**优点：**

1. 算法可以自由切换，扩展性好

2. 采用多态，避免使用多重条件判断

**缺点：**

1. 客户端要负责创建产品，功能重
2. 所有策略类都需要对外暴露

**使用场景：**

1. 若一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

2.  一个系统需要动态地在几种算法中选择一种。
3.  如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。



**改进：简单工厂模式和策略模式结合**

将对象的创建放在`Context`类中，再使用多态做出对象各自的行为。



### 装饰模式

![](img/decorator.JPG)



![](img/decorator_UML.PNG)

<font color='green'>若没有`Component`，那么可以让`Decorator`继承`ConcreteComponent`。若只有一个`ConcreteDecorator`，那就没必要加`Decorator`类。</font>



就是对于 人-衣服-裤子-鞋子 的组合，先创建人对象，让衣服包裹人，然后让裤子包裹衣服，鞋子包裹裤子：

<img src="img/example.PNG" style="zoom:30%;" />

_______________________________________

**优点：**

1. 有效地把类的核心职责和装饰功能区分开，且去除了重复逻辑
2. 为已有的功能动态地添加更多的功能

**缺点：**

1. 装饰顺序很重要，多层装饰复杂容易出错

**使用场景：**

1. 对象的创建过程是不稳定的，就像搭配衣服一样可以有好几种组合方式
1. 扩展一个类的功能
1. 动态增加功能，动态撤销

